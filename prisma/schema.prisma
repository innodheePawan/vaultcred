generator client {
  provider = "prisma-client-js"
  binaryTargets = ["native", "rhel-openssl-3.0.x", "rhel-openssl-1.0.x"]
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

// --------------------------------------
// USER & INVITE TABLES
// --------------------------------------

model User {
  id            String    @id @default(uuid()) @map("user_id")
  email         String    @unique
  passwordHash  String?
  name          String?   @map("full_name")
  role          String    @default("USER") // ADMIN, USER (No READ_ONLY, handled by groups)
  status        String    @default("ACTIVE") // ACTIVE, INACTIVE, INVITED
  profileImage  String?   @map("profile_image") @db.LongText
  
  // Invite & Auth fields
  inviteToken   String?   @map("invite_token")
  inviteExpires DateTime? @map("invite_expires")

  createdAt     DateTime  @default(now()) @map("created_on")
  updatedAt     DateTime  @updatedAt
  lastLogin     DateTime? @map("last_login")

  // Relations
  createdCredentials      CredentialMaster[] @relation("CreatedBy")
  modifiedCredentials     CredentialMaster[] @relation("ModifiedBy")
  // sharedWithMe            CredentialAccess[] // DEPRECATED: Replaced by Group Access
  auditLogs               AuditLog[]         @relation("PerformedBy")
  invitesSent             Invite[]           @relation("InvitedBy")
  
  // IAM Relations
  userGroups              UserGroupMapping[]

  @@map("users")
}

model Invite {
  id            String    @id @default(uuid()) @map("invite_id")
  email         String
  token         String    @unique @map("invite_token")
  role          String    @default("USER")
  expiresAt     DateTime  @map("expires_at")
  
  createdById   String    @map("invited_by")
  createdBy     User      @relation("InvitedBy", fields: [createdById], references: [id])
  
  createdAt     DateTime  @default(now()) @map("created_on")
  accepted      Boolean   @default(false)
  acceptedAt    DateTime? 
  
  // Store intended group assignments as JSON or simple relation? 
  // For simplicity, we can auto-assign generic groups or store IDs.
  // Storing as JSON string for now to be flexible on what groups they get on join.
  targetGroupIds String?  @map("target_group_ids") @db.Text
  
  targetScopedCategories    String?   @map("target_scoped_categories") @db.Text
  targetScopedEnvironments  String?   @map("target_scoped_environments") @db.Text

  @@map("user_invites")
}

// --------------------------------------
// IAM: GROUPS & POLICIES
// --------------------------------------

model UserGroup {
  id          String   @id @default(uuid()) @map("group_id")
  name        String   @unique @map("group_name")
  description String?
  isSystem    Boolean  @default(false) @map("is_system") // e.g. "All Users", "Admins"

  createdAt   DateTime @default(now()) @map("created_on")
  updatedAt   DateTime @updatedAt @map("updated_on")

  // Relations
  members     UserGroupMapping[]
  access      UserGroupAccess[]

  @@map("iam_user_groups")
}

model UserGroupMapping {
  userId      String    @map("user_id")
  user        User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  groupId     String    @map("group_id")
  group       UserGroup @relation(fields: [groupId], references: [id], onDelete: Cascade)
  
  assignedAt  DateTime  @default(now()) @map("assigned_at")
  assignedBy  String?   @map("assigned_by") // Audit who added them

  scopedCategories    String?   @map("scoped_categories") @db.Text
  scopedEnvironments  String?   @map("scoped_environments") @db.Text

  @@id([userId, groupId])
  @@map("iam_user_group_mapping")
}

model AccessGroup {
  id          String   @id @default(uuid()) @map("access_group_id")
  name        String   @unique @map("access_group_name") // e.g. "Engineering Read-Only"
  description String?
  
  createdAt   DateTime @default(now()) @map("created_on")
  updatedAt   DateTime @updatedAt @map("updated_on")

  // Relations
  policies    AccessGroupPolicy[]
  assignedTo  UserGroupAccess[]

  @@map("iam_access_groups")
}

model UserGroupAccess {
  userGroupId     String      @map("user_group_id")
  userGroup       UserGroup   @relation(fields: [userGroupId], references: [id], onDelete: Cascade)

  accessGroupId   String      @map("access_group_id")
  accessGroup     AccessGroup @relation(fields: [accessGroupId], references: [id], onDelete: Cascade)

  assignedAt      DateTime    @default(now()) @map("assigned_at")
  
  @@id([userGroupId, accessGroupId])
  @@map("iam_user_group_access")
}

model AccessGroupPolicy {
  id              String      @id @default(uuid()) @map("policy_id")
  
  accessGroupId   String      @map("access_group_id")
  accessGroup     AccessGroup @relation(fields: [accessGroupId], references: [id], onDelete: Cascade)

  // Policy Rules
  category        String?     // NULL = ALL, or specific category
  environment     String?     // NULL = ALL, or specific env
  permission      String      // READ, EDIT, CREATE, DOWNLOAD, ADMIN

  @@map("iam_access_group_policy")
}

// --------------------------------------
// CREDENTIAL MASTER (PARENT)
// --------------------------------------

model CredentialMaster {
  id              String    @id @default(uuid()) @map("credential_id")
  name            String    @map("credential_name")
  type            String    @map("credential_type") // PASSWORD, API_OAUTH, KEY_CERT, TOKEN, FILE, SECURE_NOTE
  category        String?   // Application, Infra, Integration
  environment     String?   // Dev, QA, Prod
  status          String    @default("ACTIVE") // ACTIVE, EXPIRED, REVOKED
  description     String?   @db.Text
  expiryDate      DateTime? @map("expiry_date")
  isPersonal      Boolean   @default(false) @map("is_personal")
  version         Int       @default(1)
  
  createdById     String    @map("created_by")
  createdBy       User      @relation("CreatedBy", fields: [createdById], references: [id])
  createdOn       DateTime  @default(now()) @map("created_on")
  
  lastModifiedById String   @map("last_modified_by")
  lastModifiedBy   User     @relation("ModifiedBy", fields: [lastModifiedById], references: [id])
  lastModifiedOn   DateTime @default(now()) @updatedAt @map("last_modified_on")

  // Child Tables (1:1)
  detailsPassword   CredPassword?
  detailsApi        CredApiOAuth?
  detailsKeyCert    CredKeyCert?
  detailsToken      CredToken?
  detailsFile       CredFile?
  detailsNote       CredSecureNote?

  // Relations
  // accessList        CredentialAccess[]
  auditLogs         AuditLog[]
  expiryNotify      ExpiryNotification[]

  @@index([type])
  @@index([status])
  @@map("credential_master")
}

// --------------------------------------
// TYPE-SPECIFIC TABLES (1:1)
// --------------------------------------

model CredPassword {
  credentialId      String   @id @map("credential_id")
  credential        CredentialMaster @relation(fields: [credentialId], references: [id], onDelete: Cascade)
  
  username          String
  passwordEncrypted String   @map("password_encrypted") @db.Text
  host              String?
  port              Int?

  @@map("cred_password")
}

model CredApiOAuth {
  credentialId      String   @id @map("credential_id")
  credential        CredentialMaster @relation(fields: [credentialId], references: [id], onDelete: Cascade)

  // OAuth / API fields
  clientId          String?  @map("client_id")
  clientSecretEnc   String?  @map("client_secret_encrypted") @db.Text
  apiKeyEncrypted   String?  @map("api_key_encrypted") @db.Text
  tokenEndpoint     String?  @map("token_url")
  authEndpoint      String?  @map("auth_url")
  scopes            String?  @db.Text 

  @@map("cred_api_oauth")
}

model CredKeyCert {
  credentialId      String   @id @map("credential_id")
  credential        CredentialMaster @relation(fields: [credentialId], references: [id], onDelete: Cascade)

  keyType           String   @map("key_type") // SSL, SSH, PGP, TLS, SIGNING
  keyFormat         String?  @map("key_format") // PEM, DER, PFX
  publicKey         String?  @map("public_key") @db.Text
  publicKeyFileName String?  @map("public_key_filename")
  privateKeyEnc     String?  @map("private_key_encrypted") @db.Text
  privateKeyFileName String? @map("private_key_filename")
  passphraseEnc     String?  @map("passphrase_encrypted") @db.Text
  
  certificateFile   String?  @map("certificate_file") @db.Text
  certificateChain  String?  @map("certificate_chain") @db.Text
  issuer            String?
  subject           String?
  algorithm         String?
  keySize           Int?     @map("key_size")
  validFrom         DateTime? @map("valid_from")
  validTo           DateTime? @map("valid_to")
  fingerprint       String?

  @@map("cred_key_cert")
}

model CredToken {
  credentialId      String   @id @map("credential_id")
  credential        CredentialMaster @relation(fields: [credentialId], references: [id], onDelete: Cascade)

  tokenEncrypted    String   @map("token_encrypted") @db.Text
  tokenType         String?  @map("token_type") // Bearer, JWT
  issuer            String?
  audience          String?
  issuedAt          DateTime? @map("issued_at")
  expiresAt         DateTime  @map("expires_at")

  @@map("cred_token")
}

model CredFile {
  credentialId      String   @id @map("credential_id")
  credential        CredentialMaster @relation(fields: [credentialId], references: [id], onDelete: Cascade)

  fileName          String?  @map("file_name")
  filePath          String   @map("file_path") // Path to storage
  fileType          String?  @map("file_type") // ZIP, TAR
  filePasswordEnc   String?  @map("file_password_encrypted") @db.Text
  fileContent       String?  @map("file_content") @db.LongText

  @@map("cred_file")
}

model CredSecureNote {
  credentialId      String   @id @map("credential_id")
  credential        CredentialMaster @relation(fields: [credentialId], references: [id], onDelete: Cascade)

  noteEncrypted     String   @map("note_encrypted") @db.LongText

  @@map("cred_secure_note")
}

model AuditLog {
  id            String    @id @default(uuid()) @map("audit_id")
  
  credentialId  String?   @map("credential_id")
  credential    CredentialMaster? @relation(fields: [credentialId], references: [id])
  
  action        String    // CREATE, UPDATE, DELETE, VIEW, DOWNLOAD, LOGIN, INVITE
  oldValue      String?   @map("old_value") @db.Text
  newValue      String?   @map("new_value") @db.Text
  
  performedById String?   @map("performed_by")
  performedBy   User?     @relation("PerformedBy", fields: [performedById], references: [id])
  
  performedOn   DateTime  @default(now()) @map("performed_on")
  ipAddress     String?   @map("ip_address")

  @@index([credentialId])
  @@index([performedById])
  @@map("audit_log")
}

model ExpiryNotification {
  id               String   @id @default(uuid()) @map("notification_id")
  credentialId     String   @map("credential_id")
  credential       CredentialMaster @relation(fields: [credentialId], references: [id])
  
  notifyBeforeDays Int      @map("notify_before_days")
  lastNotified     DateTime? @map("last_notified")

  @@map("expiry_notification")
}

model SystemSettings {
  id              Int      @id @default(1)
  applicationName String   @default("VaultSecure") @map("application_name")
  companyName     String   @default("My Company") @map("company_name")
  logoUrl         String?  @map("logo_url") @db.LongText
  themeColor      String?  @map("theme_color")
  auditPersonalCredentials Boolean @default(true) @map("audit_personal_credentials")
  
  updatedAt   DateTime @updatedAt @map("updated_on")
  updatedBy   String?  @map("updated_by")

  @@map("system_settings")
}
